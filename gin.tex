\documentclass[11pt]{article}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\usepackage{common}


\begin{document}

\hypertarget{ysql-gin-indexes}{%
\section{YSQL GIN indexes}\label{ysql-gin-indexes}}

\hypertarget{terms}{%
\subsection{Terms}\label{terms}}

\begin{oparts}
\item
  \textbf{indexed table}: indexes are on \emph{indexed tables}
\item
  \textbf{pending list}: in postgres, to avoid having each GIN index insert hit
  disk, write to a linear list of tuples (\emph{pending list}) first, and flush
  it later in bulk
\item
  \textbf{posting list}: in postgres, a GIN index tuple maps key to
  \emph{posting list}, a list of ctids corresponding to the indexed table rows
\end{oparts}

\hypertarget{background}{%
\subsection{Background}\label{background}}

\begin{sqlcode}
CREATE TABLE book (page int PRIMARY KEY, word text, position int);
\end{sqlcode}

creates a DocDB table with key \sqlinline{page HASH}. I can easily ask for
pages 5-12 using this primary key:

\begin{sqlcode}
SELECT * FROM book WHERE page >= 5 and page <= 12;
\end{sqlcode}

\begin{sqlcode}
CREATE INDEX ON book (word);
\end{sqlcode}

creates a secondary DocDB table with key \textinline{word HASH, page ASC}. This
is like the index at the back of a book. I can easily ask what pages have the
word \textinline{foo} using this index:

\begin{sqlcode}
SELECT page FROM book WHERE word = 'foo';
\end{sqlcode}

What if the table were structured instead like

\begin{sqlcode}
CREATE TABLE book (page int PRIMARY KEY, words text[]);
\end{sqlcode}

Now, looking for the specific word \textinline{foo} is time-consuming:

\begin{sqlcode}
select * from book where '{foo}' && words;
\end{sqlcode}

Creating a regular index won't help since you still need to search
\textinline{words} for \textinline{foo}.

\hypertarget{overview}{%
\subsection{Overview}\label{overview}}

GIN indexes map values \emph{inside a column} rather than the whole column.

\begin{sqlcode}
CREATE INDEX ON book USING gin (words);
\end{sqlcode}

should create a secondary DocDB table with key \textinline{word HASH, pages
ASC}, where \textinline{word} is a word in \textinline{words}. If I insert a
page with 300 unique words and 500 total words, I add 300 records to the index,
all referencing the same page.

\hypertarget{limitations}{%
\subsection{Limitations}\label{limitations}}

\begin{oparts}
\item
  GIN indexes can only be used on column types \sqlinline{tsvector},
  \sqlinline{anyarray}, \sqlinline{jsonb}
\item
  GIN indexes cannot be unique
\item
  GIN indexes can be on more than one column, but all columns must be
  GINable
\end{oparts}

\hypertarget{gin-opclasses}{%
\subsection{GIN opclasses}\label{gin-opclasses}}

Indexes have an access method (e.g. \sqlinline{btree}, \sqlinline{lsm},
\sqlinline{gin}) and an opclass (e.g. \sqlinline{char_ops},
\sqlinline{numeric_ops}). \textbf{The opclass determines the index key format!}
Here are the opclasses that can be used with GIN
(\href{https://www.postgresql.org/docs/current/gin-builtin-opclasses.html}{source}):

\begin{center}
    \begin{tabular}{lll}
        \toprule
        opclass & type & supported operators \\
        \midrule
        \sqlinline{tsvector_ops} & \sqlinline{tsvector} & \sqlinline{@@},
        \sqlinline{@@@} \\
        \sqlinline{array_ops} & \sqlinline{anyarray} & \sqlinline{&&},
        \sqlinline{@}, \sqlinline{=}, \sqlinline{@>} \\
        \sqlinline{jsonb_ops} & \sqlinline{jsonb} & \sqlinline{?},
        \sqlinline{?&}, \sqlinline{?|}, \sqlinline{@>}, \sqlinline{@?},
        \sqlinline{@@} \\
        \sqlinline{jsonb_path_ops} & \sqlinline{jsonb} & \sqlinline{@>},
        \sqlinline{@?}, \sqlinline{@@} \\
        \bottomrule
    \end{tabular}
\end{center}

If I \sqlinline{CREATE INDEX ON bar USING gin (jsonb_col)}, I implicitly use
opclass \sqlinline{jsonb_ops}. To use \sqlinline{jsonb_path_ops}, I need to
\sqlinline{CREATE INDEX ON bar USING gin (jsonb_col jsonb_path_ops)}.

\sqlinline{jsonb_ops} forms an index key for each individual piece (key or
value) of the jsonb.

\sqlinline{jsonb_path_ops} forms an index key for each path from root to leaf.

We could create our own opclass to form the keys in a way that fits with DocDB,
or we could instead have a translation layer that takes these postgres-derived
keys and converts them to DocDB format and vice versa.

\hypertarget{operators}{%
\subsection{Operators}\label{operators}}

See the operators in postgresql docs:

\begin{oparts}
\item
  \href{https://www.postgresql.org/docs/current/functions-textsearch.html}{tsvector
  operators}
\item
  \href{https://www.postgresql.org/docs/current/functions-array.html}{anyarray
  operators}
\item
  \href{https://www.postgresql.org/docs/current/functions-json.html}{jsonb
  operators}
\end{oparts}

All the operators boil down to a combination of these primitives:

\begin{oparts}
\item
  $\opget(I, f)$:
  given index $I$ and predicate $f$, return list of tuples
  \[
    T = \braces{(\ik, \pk) \in I : f(\ik)}
  \]
  $f$ should be a simple predicate like
  \begin{oparts}
  \item
    $\ik < c$
  \item
    $\ik = c$
  \item
    $\ik > c$
  \item
    $\ik \geq c$
  \item
    $\ik \leq c$
  \item
    $\ik~\textnormal{starts with}~c$
  \end{oparts}
\item
  $\opand(T_1, T_2)$:
  given list of tuples $T_1$, $T_2$, return
  \[
    T = \braces{(\ik, \pk) \in T_1 \cup T_2 : \pk \in K}
  \]
  where
  \[
    K = T_1[\pk] \cap T_2[\pk]
  \]
\item
  $\opor(T_1, T_2)$:
  given list of tuples $T_1$, $T_2$, return
  \[
    T = T_1 \cup T_2
  \]
\item
  $\oprecheck(T, g)$:
  given list of tuples $T$ and predicate $g$, return list of tuples
  \[
    T' = \braces{(\ik, \pk) \in T : g(\pk)}
  \]
  $g$ may be any predicate like
  \begin{oparts}
  \item
    \sqlinline{pk @@ '$.a.b.c.ceiling() == 5'}
  \item
    \sqlinline{pk @@ '$.d.e.f like_regex "^foo.*bar"'}
  \end{oparts}
\end{oparts}

For example, the \sqlinline{=} operator for arrays makes sure that the indexed
array column equals the query array. This can be done by

\begin{nparts}
\item
  For each distinct element in the query array $A$, get a set of tuples whose
  row's array contains the element:
  \[
    \forall c \in A, T_c = \opget(I, f)
  \]
  where
  \[
    f(\ik) = \parens{\ik \overset{?}{=} c}
  \]
\item
  Intersect the tuples to filter out any tuples whose row's array doesn't
  contain \textbf{all} of the query array's elements:
  \[
    T = \opand_{c \in A}(T_c)
  \]
\item
  Recheck each row to make sure its array has the same number of (distinct)
  elements as the query array:
  \[
    T' = \oprecheck(T, g)
  \]
  where
  \[
    g(\pk) = \parens{\verts{\braces{(i, p) \in T : p = \pk}} \overset{?}{=}
    \verts{A}}
  \]
\end{nparts}

Recheck is the fallback we can rely on for complicated queries. We can slowly
phase out the need to use recheck as DocDB becomes more capable.

See translations of all operators to primitives in
\protect\hyperlink{operators-to-primitives}{the appendix}.

\hypertarget{read-and-write-path}{%
\subsection{Read and write path}\label{read-and-write-path}}

\hypertarget{write-path}{%
\subsubsection{Write path}\label{write-path}}

For postgres, \sqlinline{INSERT INTO table_with_gin_index
(to_tsvector('simple', 'the quick brown'))} does

\begin{nparts}
\item
  prepare index keys: \textinline{the}, \textinline{quick}, \textinline{brown}
\item
  for each index key, append the indexed table ctid to the key's posting list
\end{nparts}

For Yugabyte, we should

\begin{nparts}
\item
  prepare index keys: \textinline{the}, \textinline{quick}, \textinline{brown}
\item
  \textbf{for each index key, write (key, ctid) pair to DocDB}
\end{nparts}

\hypertarget{read-path}{%
\subsubsection{Read path}\label{read-path}}

For postgres, \sqlinline{SELECT * FROM table_with_gin_index WHERE tscol @@
to_tsquery('simple', 'the')} does

\begin{nparts}
\item
  create scan key: \textinline{the}
\item
  get tuples matching scan key
\item
  recheck each tuple if needed
\end{nparts}

For Yugabyte, we should

\begin{nparts}
\item
  create scan key: \textinline{the}
\item
  \textbf{fetch tuples from DocDB matching scan key}
\item
  recheck each tuple if needed
\end{nparts}

\hypertarget{docdb-encoding}{%
\subsection{DocDB encoding}\label{docdb-encoding}}

In general, GIN index records should be encoded like

\begin{textcode*}{frame=none}
[<gin_index_keys>, <primary_keys>]
\end{textcode*}

\hypertarget{tsvector}{%
\subsubsection{tsvector}\label{tsvector}}

The GIN index key should be words, like \textinline{the}, \textinline{quick},
\textinline{brown}. To support prefix search, serialization of the words should
be done carefully.

TODO: look into DocDB encoding for \cppinline{kString}. TODO: look into
\textinline{tsvector} \textbf{weights}

\hypertarget{jsonb}{%
\subsubsection{jsonb}\label{jsonb}}

The GIN index key should be paths, like

\begin{oparts}
\item
  \textinline{<JSON>, a, 1}
\item
  \textinline{<JSON>, b, <JSON>, c, d}
\item
  \textinline{<JSON>, b, <JSON>, c, e}
\item
  \textinline{<JSON>, b, <ARRAY>, 1}
\item
  \textinline{<JSON>, b, <ARRAY>, <ARRAY>, 2}
\item
  \textinline{<JSON>, b, <ARRAY>, <ARRAY>, 3}
\item
  \textinline{<JSON>, b, <ARRAY>, 4}
\item
  \textinline{<JSON>, c, f}
\end{oparts}

(This is inspired by
\href{https://github.com/cockroachdb/cockroach/blob/master/docs/RFCS/20171020_inverted_indexes.md}{CockroachDB's
inverted index RFC}.)

Contains (\sqlinline{@>}) searches can have corresponding scan keys

\begin{oparts}
\item
  \sqlinline{j @> '{"a": 1}'}
  scans for \textinline{<JSON>, a, 1}
\item
  \sqlinline{j @> '{"b": {}}'}
  scans for
  \textinline{<JSON>, b, <JSON>}
\item
  \sqlinline{j @> '{"b": []}'}
  scans for
  \textinline{<JSON>, b, <ARR>}
\item
  \sqlinline{j @> '{"b": [[]]}'}
  scans for
  \textinline{<JSON>, b, <ARR>, <ARR>}
\item
  \sqlinline{j @> '{"b": [4]}'}
  scans for
  \textinline{<JSON>, b, <ARR>, 4}
\end{oparts}

Concerns

\begin{oparts}
\item
  \sqlinline{25.0} and \sqlinline{25} match should equally match--what will the
  number format be like?
\item
  What will the text encoding be like, especially for weird unicode, and how
  does prefix matching work, then?
\item
  How will the end of the JSON document be marked? (Same question for marking
  array end on array GIN index.) \cppinline{kGroupEnd}? But doesn't this mean
  the contents of the JSON GIN key have to be encoded in some way to make
  exclamation marks unambiguous?
\end{oparts}

\hypertarget{appendix}{%
\section{Appendix}\label{appendix}}

\hypertarget{key-format-for-normal-index}{%
\subsection{Key format for normal
index}\label{key-format-for-normal-index}}

Here is a step-by-step guide to see how normal indexes are represented in
DocDB.

\begin{bashcode}
./bin/yb-ctl create \
  --master_flags "ysql_disable_index_backfill=true" \
  --tserver_flags "TEST_docdb_log_write_batches=true,ysql_disable_index_backfill=true,ysql_num_shards_per_tserver=1"
tail -F ~/yugabyte-data/node-1/disk-1/yb-data/tserver/logs/yb-tserver.INFO
\end{bashcode}

\begin{sqlcode}
CREATE TABLE t (p bool PRIMARY KEY, c char, i int);
INSERT INTO t VALUES (true, 'b', 2);
INSERT INTO t VALUES (false, null, null);
\end{sqlcode}

\begin{sqlcode}
CREATE INDEX ON t (c);
\end{sqlcode}

Observe logs for \emph{regular} DocDB writes

\begin{textcode}
I0216 18:08:50.375550 31976 tablet.cc:1235] T dfc95b4d53b44afebc4827b29bcc6769 P 5fb87e8c88ea477ab7ebb4b9a3bb4bdc: Wrote 2 key/value pairs to kRegular RocksDB:
Frontiers: { smallest: { op_id: 1.3 hybrid_time: { physical: 1613527730374840 } history_cutoff: <invalid> hybrid_time_filter: <invalid> } largest: { op_id: 1.3 hybrid_time: { physical: 1613527730374840 } history_cutoff: <invalid> hybrid_time_filter: <invalid> } }
1. PutCF(SubDocKey(DocKey(0xebd4, ["b"], ["G\x8f\xf7T!!"]), [SystemColumnId(0); HT{ physical: 1613527730370761 }]), '#\x80\x01\x98\xbfC\xf5\xd5\xab\x80J$' (23800198BF43F5D5AB804A24))
2. PutCF(SubDocKey(DocKey(0x4d44, [null], ["G\xdc@F!!"]), [SystemColumnId(0); HT{ physical: 1613527730370761 w: 1 }]), '#\x80\x01\x98\xbfC\xf5\xd5\xab\x80?\xab$' (23800198BF43F5D5AB803FAB24))
\end{textcode}

In simpler terms,

\begin{nparts}
\item
  \textinline{["b", true]}
\item
  \textinline{[null, false]}
\end{nparts}

\textinline{IndexScan} on \sqlinline{c = 'b'} can look in this index for
\textinline{["b"]} prefix, get the next key component \textinline{true}, then
look up \textinline{true} in the indexed table.

\begin{sqlcode}
CREATE UNIQUE INDEX ON t (i);
\end{sqlcode}

Observe logs for \emph{regular} DocDB writes

\begin{textcode}
I0216 18:10:06.280701 31753 tablet.cc:1235] T bb21a24b24eb421b8b7a84fb03422271 P 5fb87e8c88ea477ab7ebb4b9a3bb4bdc: Wrote 4 key/value pairs to kRegular RocksDB:
Frontiers: { smallest: { op_id: 1.3 hybrid_time: { physical: 1613527806280035 } history_cutoff: <invalid> hybrid_time_filter: <invalid> } largest: { op_id: 1.3 hybrid_time: { physical: 1613527806280035 } history_cutoff: <invalid> hybrid_time_filter: <invalid> } }
1. PutCF(SubDocKey(DocKey(0xc0c4, [2], [null]), [SystemColumnId(0); HT{ physical: 1613527806278239 }]), '#\x80\x01\x98\xbf?o\x8e\x93\x80J$' (23800198BF3F6F8E93804A24))
2. PutCF(SubDocKey(DocKey(0xc0c4, [2], [null]), [ColumnId(12); HT{ physical: 1613527806278239 w: 1 }]), '#\x80\x01\x98\xbf?o\x8e\x93\x80?\xabSG\x8f\xf7T!!' (23800198BF3F6F8E93803FAB53478FF7542121))
3. PutCF(SubDocKey(DocKey(0x4d44, [null], ["G\xdc@F!!"]), [SystemColumnId(0); HT{ physical: 1613527806278239 w: 2 }]), '#\x80\x01\x98\xbf?o\x8e\x93\x80?\x8b$' (23800198BF3F6F8E93803F8B24))
4. PutCF(SubDocKey(DocKey(0x4d44, [null], ["G\xdc@F!!"]), [ColumnId(12); HT{ physical: 1613527806278239 w: 3 }]), '#\x80\x01\x98\xbf?o\x8e\x93\x80?kSG\xdc@F!!' (23800198BF3F6F8E93803F6B5347DC40462121))
\end{textcode}

In simpler terms,

\begin{nparts}
\item
  \textinline{[2, null]} -\textgreater{} \textinline{true}
\item
  \textinline{[null, false]} -\textgreater{} \textinline{false}
\end{nparts}

\textinline{IndexScan} on \sqlinline{i = 2} can look in this index for
\textinline{[2]} prefix, get the value \textinline{true}, then look up
\textinline{true} in the indexed table.

\hypertarget{operators-to-primitives}{%
\subsection{Operators to primitives}\label{operators-to-primitives}}

You can represent each GIN operator using the primitives:

\begin{oparts}
\item
  \texttt{tsvector\ @@\ tsquery\ →\ boolean}: (custom)

  \begin{oparts}
  \item
    tsquery \texttt{a\ \textbar{}\ b}: (set \texttt{LHS} contains
    element \texttt{a}) OR (set \texttt{LHS} contains element
    \texttt{b})
  \item
    tsquery \texttt{a\ \&\ b}: (set \texttt{LHS} contains element
    \texttt{a}) AND (set \texttt{LHS} contains element \texttt{b})
  \item
    tsquery \texttt{!a}: NOT(set \texttt{LHS} contains element
    \texttt{a})
  \item
    tsquery \texttt{a:*\textquotesingle{}}: (set \texttt{LHS} contains
    element \textbf{with prefix} \texttt{a})
  \end{oparts}
\item
  \texttt{anyarray\ \&\&\ anyarray\ →\ boolean}: OR(set \texttt{LHS}
  contains element \texttt{RHS{[}*{]}})
\item
  \texttt{anyarray\ \textless{}@\ anyarray\ →\ boolean}: OR(set
  \texttt{LHS} contains element \texttt{RHS{[}*{]}}) + recheck
\item
  \texttt{anyarray\ =\ anyarray\ →\ boolean}: AND(set \texttt{LHS}
  contains element \texttt{RHS{[}*{]}}) + recheck
\item
  \texttt{anyarray\ @\textgreater{}\ anyarray\ →\ boolean}: AND(set
  \texttt{LHS} contains element \texttt{RHS{[}*{]}})
\item
  \texttt{jsonb\ ?\ text\ →\ boolean}: set \texttt{LHS} contains element
  \texttt{RHS}
\item
  \texttt{jsonb\ ?\&\ text{[}{]}\ →\ boolean}: AND(set \texttt{LHS}
  contains element \texttt{RHS{[}*{]}})
\item
  \texttt{jsonb\ ?\textbar{}\ text{[}{]}\ →\ boolean}: OR(set
  \texttt{LHS} contains element \texttt{RHS{[}*{]}})
\item
  \texttt{jsonb\ @\textgreater{}\ jsonb\ →\ boolean}: AND(set
  \texttt{LHS} contains element \texttt{RHS{[}*{]}})
\item
  \texttt{jsonb\ @?\ jsonpath\ →\ boolean}: (custom)
\item
  \texttt{jsonb\ @@\ jsonpath\ →\ boolean}: (custom)

  \begin{oparts}
  \item
    jsonpath \texttt{\$.a\ ==\ 7}: set \texttt{LHS} contains element
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}7}
  \item
    jsonpath \texttt{\$.a\ \textgreater{}\ 7}: (set \texttt{LHS}
    contains element \textbf{greater than}
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}7})
    AND (set \texttt{LHS} contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}})
  \item
    jsonpath \texttt{\$.a\ !=\ 7}: (set \texttt{LHS} contains element
    \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}})
    AND NOT(set \texttt{LHS} contains element
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}7})
  \item
    jsonpath \texttt{(\$.a\ ==\ 7)\ \&\&\ !\ (\$.b\ ==\ 8)}: (set
    \texttt{LHS} contains element
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}7})
    AND NOT(set \texttt{LHS} contains element
    \texttt{\textless{}key\textgreater{}b.\textless{}num\textgreater{}8})
  \item
    jsonpath \texttt{\$.a\ like\_regex\ "\^{}foo.*bar"}: set
    \texttt{LHS} contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}str\textgreater{}}
    + recheck
  \item
    jsonpath \texttt{\$.a\ starts\ with\ "bar"}: set \texttt{LHS}
    contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}str\textgreater{}bar}
  \item
    jsonpath \texttt{\$.a.ceiling()\ ==\ 5}: set \texttt{LHS} contains
    element
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}}
    + recheck
  \item
    jsonpath \texttt{\$.a.type()\ ==\ "number"}: set \texttt{LHS}
    contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}}
  \item
    jsonpath \texttt{\$.a\ +\ (\$.b\ \%\ \$.c)\ ==\ 7}: (set
    \texttt{LHS} contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}})
    AND (set \texttt{LHS} contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}b.\textless{}num\textgreater{}})
    AND (set \texttt{LHS} contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}c.\textless{}num\textgreater{}})
    + recheck
  \end{oparts}
\end{oparts}

\hypertarget{example-tsvector}{%
\subsection{Example: tsvector}\label{example-tsvector}}

Here is an example of using a tsvector GIN index. It is inspired by a
\href{https://habr.com/en/company/postgrespro/blog/448746/}{habr blog}.  Run on
upstream postgres.

\begin{sqlcode}
CREATE TABLE docs (
    doc text,
    ts tsvector GENERATED ALWAYS AS (to_tsvector('simple', doc)) STORED);
INSERT INTO docs (doc) VALUES
  ('Can a sheet slitter slit sheets?'),
  ('How many sheets could a sheet slitter slit?'),
  ('I slit a sheet, a sheet I slit.'),
  ('Upon a slitted sheet I sit.'),
  ('Whoever slit the sheets is a good sheet slitter.'),
  ('I am a sheet slitter.'),
  ('I slit sheets.'),
  ('I am the sleekest sheet slitter that ever slit sheets.'),
  ('She slits the sheet she sits on.');
SELECT * FROM docs; -- what tsvector looks like
\end{sqlcode}

\begin{sqlcode}
CREATE INDEX ON docs USING GIN (ts);
SET enable_seqscan = OFF;
EXPLAIN SELECT * FROM docs
    WHERE ts @@ to_tsquery('simple', 'many'); -- this is index scan
\end{sqlcode}

Example of what can be done, all using the index:

\begin{sqlcode}
SELECT doc FROM docs WHERE ts @@ to_tsquery('simple', 'many & slitter');
SELECT doc FROM docs WHERE ts @@ to_tsquery('simple', 'many | slitter');
SELECT doc FROM docs WHERE ts @@ to_tsquery('simple', 'slit:* & !slit');
SELECT ts_rank(ts, to_tsquery('simple', 'i & sheet:* & slit:*')) as rank, doc
    FROM docs
    WHERE ts @@ to_tsquery('simple', 'i & sheet:* & slit:*')
    ORDER BY rank DESC;
\end{sqlcode}

\hypertarget{example-jsonb}{%
\subsection{Example: jsonb}\label{example-jsonb}}

Here is an example of using a jsonb GIN index.

\begin{sqlcode}
CREATE TABLE records (p SERIAL PRIMARY KEY, j jsonb);
INSERT INTO records (j) VALUES
  ('{"a": 1}'),
  ('{"b": {"c": "d"}}'),
  ('{"b": {"c": "e"}}'),
  ('{"b": [1, [2, 3], 4], "c": "f"}');
CREATE INDEX ON records USING GIN (j jsonb_ops);
SET enable_seqscan = OFF;
EXPLAIN SELECT * FROM records WHERE j @> '{"b": {}}'; -- this is index scan
\end{sqlcode}

Example of what can be done, all using the index:

\begin{sqlcode}
SELECT * FROM records WHERE j @> '{"b": {}}';
SELECT * FROM records WHERE j ? 'c';
SELECT * FROM records WHERE j ?| ARRAY['a', 'c'];
SELECT * FROM records WHERE j ?& ARRAY['c', 'b'];
SELECT * FROM records WHERE j @? '$.b[*] ? (@ > 3)';
SELECT * FROM records WHERE j @@ '$.b.c == "e"';
\end{sqlcode}

You can think of

\begin{sqlcode}
SELECT * FROM records WHERE j @? '$.b[*] ? (@ == 3)';
\end{sqlcode}

to be like

\begin{sqlcode}
SELECT * FROM records WHERE (
    j @@ '$.b[0] == 3' or
    j @@ '$.b[1] == 3' or
    j @@ '$.b[2] == 3');
\end{sqlcode}

\hypertarget{advanced-material}{%
\section{Advanced material}\label{advanced-material}}

These are some more involved details that can be helpful to developers.

\hypertarget{read-and-write-path-extended}{%
\subsection{Read and write path
extended}\label{read-and-write-path-extended}}

\hypertarget{write-path-extended}{%
\subsubsection{Write path extended}\label{write-path-extended}}

\sqlinline{INSERT INTO table_with_gin_index (to_tsvector('simple', 'the quick
brown'))} does

\begin{nparts}
\item
  insert to main table (\cinline{ExecInsert}, \cinline{table_tuple_insert})
\item
  insert to gin index (\cinline{ExecInsert}, \cinline{ExecInsertIndexTuples})

  \begin{qparts}
  \item
    if fast update is enabled, write index tuples to pending list
    (\cinline{gininsert}, \cinline{ginHeapTupleFastInsert})
  \item
    otherwise, write index tuples to disk (\cinline{gininsert},
    \cinline{ginHeapTupleInsert})

    \begin{iparts}
    \item
      prepare index keys: \textinline{the}, \textinline{quick},
      \textinline{brown} (\cinline{ginHeapTupleInsert},
      \cinline{ginExtractEntries})
    \item
      if tuple with key already exists, append the indexed table ctid to the
      posting list (\cinline{ginEntryInsert},
      \cinline{addItemPointersToLeafTuple})
    \item
      otherwise, create a posting list containing just the indexed table ctid
      (\cinline{ginEntryInsert}, \cinline{buildFreshLeafTuple})
    \end{iparts}
  \end{qparts}
\end{nparts}

\hypertarget{read-path-extended}{%
\subsubsection{Read path extended}\label{read-path-extended}}

\sqlinline{SELECT * FROM table_with_gin_index WHERE tscol @@
to_tsquery('simple', 'the')} does

\begin{nparts}
\item
  create scan key: \textinline{the} (\cinline{gingetbitmap},
  \cinline{ginNewScanKey})
\item
  get blocks from pending list (\cinline{gingetbitmap},
  \cinline{scanPendingInsert})
\item
  get blocks from disk (\cinline{gingetbitmap}, \cinline{startScan})
\item
  get tuples from blocks (\cinline{BitmapHeapNext},
  \cinline{table_scan_bitmap_next_tuple})
\item
  recheck tuple if needed (\cinline{BitmapHeapNext},
  \cinline{ExecQualAndReset})
\end{nparts}

\hypertarget{execution-trees}{%
\subsection{Execution trees}\label{execution-trees}}

\hypertarget{read}{%
\subsubsection{Read}\label{read}}

\begin{textcode}
exec_simple_query
  PortalStart
    ExecutorStart
      standard_ExecutorStart
        InitPlan
          ExecInitNode
            ExecInitBitmapHeapScan
              ExecInitNode
                ExecInitBitmapIndexScan
                  index_beginscan_bitmap
                    index_beginscan_internal
                      ambeginscan
  PortalRun
    PortalRunSelect
      ExecutorRun
        standard_ExecutorRun
          ExecutePlan
            ... ExecBitmapHeapScan
              ExecScanFetch
                BitmapHeapNext
                  MultiExecProcNode
                    MultiExecBitmapIndexScan
                      index_getbitmap
                        gingetbitmap
                    MultiExecBitmapAnd
                    MultiExecBitmapOr
\end{textcode}

Entry point for using text search functions:

\begin{textcode}
(gdb) bt
#0  TS_execute (curitem=0x1749d90, arg=arg@entry=0x7ffdf8c8ea50, flags=flags@entry=2, chkcond=chkcond@entry=0x842ad0 <checkcondition_gin>) at tsvector_op.c:1848
#1  0x00000000008430c3 in gin_tsquery_triconsistent (fcinfo=<optimized out>) at tsginidx.c:287
#2  0x0000000000881fdd in FunctionCall7Coll (flinfo=0x17ffe98, collation=<optimized out>, arg1=<optimized out>, arg2=<optimized out>, arg3=<optimized out>, arg4=<optimized out>, arg5=25151648, arg6=25151592, arg7=25151768) at fmgr.c:1311
#3  0x000000000049dc10 in directTriConsistentFn (key=<optimized out>) at ginlogic.c:97
#4  0x000000000049c39f in startScanKey (ginstate=0x17fe580, so=0x17fe578, so=0x17fe578, key=0x17fc648) at ginget.c:566
#5  startScan (scan=0x17e73f0, scan=0x17e73f0) at ginget.c:642
#6  gingetbitmap (scan=0x17e73f0, tbm=0x18053d8) at ginget.c:1951
#7  0x00000000004d3d9a in index_getbitmap (scan=scan@entry=0x17e73f0, bitmap=bitmap@entry=0x18053d8) at indexam.c:671
#8  0x0000000000632882 in MultiExecBitmapIndexScan (node=0x17e7100) at nodeBitmapIndexscan.c:105
#9  0x00000000006220e1 in MultiExecProcNode (node=<optimized out>) at execProcnode.c:510
#10 0x0000000000631f50 in BitmapHeapNext (node=node@entry=0x17e6e10) at nodeBitmapHeapscan.c:113
#11 0x00000000006245fa in ExecScanFetch (recheckMtd=0x6321c0 <BitmapHeapRecheck>, accessMtd=0x631820 <BitmapHeapNext>, node=0x17e6e10) at execScan.c:133
#12 ExecScan (node=0x17e6e10, accessMtd=0x631820 <BitmapHeapNext>, recheckMtd=0x6321c0 <BitmapHeapRecheck>) at execScan.c:199
#13 0x000000000061af52 in ExecProcNode (node=0x17e6e10) at ../../../src/include/executor/executor.h:248
#14 ExecutePlan (execute_once=<optimized out>, dest=0x17f5ba8, direction=<optimized out>, numberTuples=0, sendTuples=true, operation=CMD_SELECT, use_parallel_mode=<optimized out>, planstate=0x17e6e10, estate=0x17e6be8) at execMain.c:1646
#15 standard_ExecutorRun (queryDesc=0x17f9738, direction=<optimized out>, count=0, execute_once=<optimized out>) at execMain.c:364
#16 0x0000000000770afb in PortalRunSelect (portal=portal@entry=0x178b008, forward=forward@entry=true, count=0, count@entry=9223372036854775807, dest=dest@entry=0x17f5ba8) at pquery.c:912
#17 0x0000000000771d68 in PortalRun (portal=portal@entry=0x178b008, count=count@entry=9223372036854775807, isTopLevel=isTopLevel@entry=true, run_once=run_once@entry=true, dest=dest@entry=0x17f5ba8, altdest=altdest@entry=0x17f5ba8, qc=qc@entry=0x7ffdf8c8
efe0) at pquery.c:756
#18 0x000000000076dabe in exec_simple_query (query_string=0x1724c68 "SELECT doc FROM docs WHERE ts @@ to_tsquery('simple', 'many & slitter');") at postgres.c:1239
#19 0x000000000076ee37 in PostgresMain (argc=<optimized out>, argv=argv@entry=0x174f0b8, dbname=0x174f000 "testupdatejoin", username=<optimized out>) at postgres.c:4315
#20 0x0000000000481e23 in BackendRun (port=<optimized out>, port=<optimized out>) at postmaster.c:4536
#21 BackendStartup (port=0x1748270) at postmaster.c:4220
#22 ServerLoop () at postmaster.c:1739
#23 0x00000000006fc793 in PostmasterMain (argc=argc@entry=3, argv=argv@entry=0x171f980) at postmaster.c:1412
#24 0x0000000000482a6e in main (argc=3, argv=0x171f980) at main.c:210
\end{textcode}

\hypertarget{constants}{%
\subsection{Constants}\label{constants}}

\begin{ccode}
#define JsonbContainsStrategyNumber   7
#define JsonbExistsStrategyNumber   9
#define JsonbExistsAnyStrategyNumber  10
#define JsonbExistsAllStrategyNumber  11
#define JsonbJsonpathExistsStrategyNumber   15
#define JsonbJsonpathPredicateStrategyNumber  16
\end{ccode}

\hypertarget{misc}{%
\subsection{Misc}\label{misc}}

\begin{oparts}
\item
  At \cinline{ginbeginscan},

\begin{textcode}
(gdb) p so->ginstate
$32 = {
  index = 0x7fbef38c56f0,
  oneCol = true,
  origTupdesc = 0x7fbef38c5a10,
  tupdesc = {0x7fbef38c5a10, 0x0 <repeats 31 times>},
  compareFn = {{
      fn_addr = 0x842b30 <gin_cmp_tslexeme>,
      fn_oid = 3724,
      fn_nargs = 2,
      fn_strict = true,
      fn_retset = false,
      fn_stats = 2 '\002',
      fn_extra = 0x0,
      fn_mcxt = 0x17e5760,
      fn_expr = 0x17ee788
    }, {
      fn_addr = 0x0,
      fn_oid = 0,
      fn_nargs = 0,
      fn_strict = false,
      fn_retset = false,
      fn_stats = 0 '\000',
      fn_extra = 0x0,
      fn_mcxt = 0x0,
      fn_expr = 0x0
    } <repeats 31 times>},
  extractValueFn = {{
      fn_addr = 0x842d90 <gin_extract_tsvector>,
      fn_oid = 3656,
      fn_nargs = 3,
      fn_strict = true,
      fn_retset = false,
      fn_stats = 2 '\002',
      fn_extra = 0x0,
      fn_mcxt = 0x17e5760,
      fn_expr = 0x17eea70
    }, {
      fn_addr = 0x0,
      fn_oid = 0,
      fn_nargs = 0,
      fn_strict = false,
      fn_retset = false,
      fn_stats = 0 '\000',
      fn_extra = 0x0,
      fn_mcxt = 0x0,
      fn_expr = 0x0
    } <repeats 31 times>},
  extractQueryFn = {{
      fn_addr = 0x842e30 <gin_extract_tsquery>,
      fn_oid = 3657,
      fn_nargs = 7,
      fn_strict = true,
      fn_retset = false,
      fn_stats = 2 '\002',
      fn_extra = 0x0,
      fn_mcxt = 0x17e5760,
      fn_expr = 0x17eeac0
    }, {
      fn_addr = 0x0,
      fn_oid = 0,
      fn_nargs = 0,
      fn_strict = false,
      fn_retset = false,
      fn_stats = 0 '\000',
      fn_extra = 0x0,
      fn_mcxt = 0x0,
      fn_expr = 0x0
    } <repeats 31 times>},
  consistentFn = {{
      fn_addr = 0x843000 <gin_tsquery_consistent>,
      fn_oid = 3658,
      fn_nargs = 8,
      fn_strict = true,
      fn_retset = false,
      fn_stats = 2 '\002',
      fn_extra = 0x0,
      fn_mcxt = 0x17e5760,
      fn_expr = 0x17eeb60
    }, {
      fn_addr = 0x0,
      fn_oid = 0,
      fn_nargs = 0,
      fn_strict = false,
      fn_retset = false,
      fn_stats = 0 '\000',
      fn_extra = 0x0,
      fn_mcxt = 0x0,
      fn_expr = 0x0
    } <repeats 31 times>},
  triConsistentFn = {{
      fn_addr = 0x843070 <gin_tsquery_triconsistent>,
      fn_oid = 3921,
      fn_nargs = 7,
      fn_strict = true,
      fn_retset = false,
      fn_stats = 2 '\002',
      fn_extra = 0x0,
      fn_mcxt = 0x17e5760,
      fn_expr = 0x17eeb10
    }, {
      fn_addr = 0x0,
      fn_oid = 0,
      fn_nargs = 0,
      fn_strict = false,
      fn_retset = false,
      fn_stats = 0 '\000',
      fn_extra = 0x0,
      fn_mcxt = 0x0,
      fn_expr = 0x0
    } <repeats 31 times>},
  comparePartialFn = {{
      fn_addr = 0x842c50 <gin_cmp_prefix>,
      fn_oid = 2700,
      fn_nargs = 4,
      fn_strict = true,
      fn_retset = false,
      fn_stats = 2 '\002',
      fn_extra = 0x0,
      fn_mcxt = 0x17e5760,
      fn_expr = 0x17ff748
    }, {
      fn_addr = 0x0,
      fn_oid = 0,
      fn_nargs = 0,
      fn_strict = false,
      fn_retset = false,
      fn_stats = 0 '\000',
      fn_extra = 0x0,
      fn_mcxt = 0x0,
      fn_expr = 0x0
    } <repeats 31 times>},
  canPartialMatch = {true, false <repeats 31 times>},
  supportCollation = {100, 0 <repeats 31 times>}
}
\end{textcode}
\end{oparts}

\end{document}
