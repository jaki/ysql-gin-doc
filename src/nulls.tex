GIN indexes have more than one type of null:

\begin{oparts}
\item
  \cinline{GIN_CAT_NULL_KEY}: null element in the container (e.g.\
  \sqlinline{'{null}'})
\item
  \cinline{GIN_CAT_EMPTY_ITEM}: container without any element (e.g.\
  \sqlinline{'{}'})
\item
  \cinline{GIN_CAT_NULL_ITEM}: null container (i.e.\ \sqlinline{null})
\end{oparts}

They are often used with search modes:

\begin{oparts}
\item
  \cinline{GIN_SEARCH_MODE_INCLUDE_EMPTY}: match \cinline{GIN_CAT_EMPTY_ITEM}
  (e.g.\ \sqlinline{somearray <@ '{1}'})
\item
  \cinline{GIN_SEARCH_MODE_ALL}: match everything but
  \cinline{GIN_CAT_NULL_ITEM} (e.g.\ \sqlinline{somearray @> '{}'})
\item
  \cinline{GIN_SEARCH_MODE_EVERYTHING}: match everything (e.g.\
  \sqlinline{somearray is null} when there is a partial index on that same
  condition)
\end{oparts}

I don't think that there's a way to avoid having multiple null categories
because they are distinguished in certain scans.  The question is how to
represent these null categories in DocDB.\@

DocDB currently stores nulls as \cppinline{ValueType::kNullHigh} and
\cppinline{ValueType::kNullLow}.  They are single bytes by themselves, so it's
not easy to extend them to hold categories.\footnote{see
\cppinline{InitKeyColumnPrimitiveValues} $\rightarrow$ \cppinline{IsNull}}  I
see two possible solutions:

\begin{nparts}
\item
  Create a new pair of value types that allocate one byte after to determine
  the category number.
\item
  Use the existing null value types but store metadata to the table schema
  indicating that the table is a gin table so that these nulls are interpreted
  as holding the category number on the following byte.
\end{nparts}

Another consideration is sorting.  For user-facing sort ASC/DESC and NULLS
FIRST/LAST, GIN doesn't really play a role since this sort happens on the
container, not the elements.  However, internally, we may still want to
guarantee certain sort orders for DocDB.\@  For example, if we do an IN read,
the array of values must be sorted when passed to DocDB.\@  I'm not too sure
why the limitation is there, but this may mean that the order of nulls in the
IN scan matters with respect to their ordering in DocDB.\@
\cinline{GIN_CAT_EMPTY_ITEM} should sort either before or after any other
regular value.  However, it's very cramped,\footnote{see
\textinline{value_type.h}} and I don't think there's any space for new value
types that are in the fringes.  Therefore, the second solution of reusing the
existing null value types seems like the only option.
