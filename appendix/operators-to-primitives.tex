\hypertarget{operators-to-primitives}{%
\subsection{Operators to primitives}\label{operators-to-primitives}}

You can represent each GIN operator using the primitives:

\begin{center}
  \begin{tabular}{lll}
    \toprule
    signature & translation & notes \\
    \midrule
    \sqlinline{tsvector @@ tsquery} \\
    $\hookrightarrow$ \sqlinline{tsquery}: \sqlinline{|}
        & Given \sqlinline{col @@ 'foo | bar'}, \\
      & $T_l = \opget_I(i \qeq \mathtt{foo})$ \\
      & $T_r = \opget_I(i \qeq \mathtt{bar})$ \\
      & $T = \opor(T_l, T_r)$ \\
    $\hookrightarrow$ \sqlinline{tsquery}: \sqlinline{&}
        & Given \sqlinline{col @@ 'foo & bar'}, \\
      & $T_l = \opget_I(i \qeq \mathtt{foo})$ \\
      & $T_r = \opget_I(i \qeq \mathtt{bar})$ \\
      & $T = \opand(T_l, T_r)$ \\
    $\hookrightarrow$ \sqlinline{tsquery}: \sqlinline{!}
        & Given \sqlinline{col @@ '!foo'},
        & expensive; \\
      & $T = \opget_I(i \qeq \mathtt{foo})$
        & mem $\propto$ commonness of RHS \\
      & seqscan tuples where pkey $p \not\in T[\pk]$ \\
    $\hookrightarrow$ \sqlinline{tsquery}: \sqlinline{:*}
        & Given \sqlinline{col @@ 'foo:*'}, \\
      & $T = \opget_I(i \qsw \mathtt{foo})$
        & need range-partition \\
    \bottomrule
  \end{tabular}
\end{center}

\begin{center}
  \begin{tabular}{lll}
    \toprule
    signature & translation & notes \\
    \midrule
    \sqlinline{anyarray && anyarray}
        & Given \sqlinline{col && [3, 7]}, \\
      & $T_3 = \opget_I(i \qeq \mathtt{3})$ \\
      & $T_7 = \opget_I(i \qeq \mathtt{7})$ \\
      & $T = \opor(T_3, T_7)$ \\
    \sqlinline{anyarray <@ anyarray}
        & Given \sqlinline{col <@ [3, 7]},
        & likely cheap: \\
      & $T_3 = \opget_I(i \qeq \mathtt{3})$
        & cost $\propto$ size of RHS \\
      & $T_7 = \opget_I(i \qeq \mathtt{7})$ \\
      & $T = \opor(T_3, T_7)$ \\
      & seqscan tuples where pkey $p \in T[\pk]$ \\
      & and recheck the operator \\
    \sqlinline{anyarray = anyarray}
        & Given \sqlinline{col = [3, 7]},
        & cheap; \\
      & $T_3 = \opget_I(i \qeq \mathtt{3})$
        & mem $\propto$ size of RHS \\
      & $T_7 = \opget_I(i \qeq \mathtt{7})$ \\
      & $T = \opand(T_3, T_7)$ \\
      & $T' = \oprecheck(T, \verts{\braces{(i', p') \in T : p' = p}} \qeq 2)$
          \\
    \sqlinline{anyarray @> anyarray}
        & Given \sqlinline{col @> [3, 7]}, \\
      & $T_3 = \opget_I(i \qeq \mathtt{3})$ \\
      & $T_7 = \opget_I(i \qeq \mathtt{7})$ \\
      & $T = \opand(T_3, T_7)$ \\
    \bottomrule
  \end{tabular}
\end{center}

\begin{center}
  \begin{tabular}{lll}
    \toprule
    signature & translation & notes \\
    \midrule
    \sqlinline{jsonb ? text}
        & Given \sqlinline{col ? 'foo'}, \\
      & $T = \opget_I(i \qsw \mathtt{Jfoo})$ \\
    \sqlinline{jsonb ?& text[]}
        & Given \sqlinline{col ?& ARRAY['foo', 'bar']}, \\
      & $T_l = \opget_I(i \qsw \mathtt{Jfoo})$ \\
      & $T_r = \opget_I(i \qsw \mathtt{Jbar})$ \\
      & $T = \opand(T_l, T_r)$ \\
    \sqlinline{jsonb ?| text[]}
        & Given \sqlinline{col ?| ARRAY['foo', 'bar']}, \\
      & $T_l = \opget_I(i \qsw \mathtt{Jfoo})$ \\
      & $T_r = \opget_I(i \qsw \mathtt{Jbar})$ \\
      & $T = \opor(T_l, T_r)$ \\
    \sqlinline{jsonb @> jsonb}
        & Given \sqlinline{col @> '{"a":3, "b":{"c":["d"]}}'}, \\
      & $T_1 = \opget_I(i \qeq \mathtt{JaN3})$ \\
      & $T_2 = \opget_I(i \qeq \mathtt{JbJcASd})$ \\
      & $T = \opor(T_1, T_2)$ \\
    \bottomrule
  \end{tabular}
\end{center}

\begin{oparts}
\item
  \texttt{jsonb\ @?\ jsonpath\ →\ boolean}: (custom)
\item
  \texttt{jsonb\ @@\ jsonpath\ →\ boolean}: (custom)

  \begin{oparts}
  \item
    jsonpath \texttt{\$.a\ ==\ 7}: set \texttt{LHS} contains element
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}7}
  \item
    jsonpath \texttt{\$.a\ \textgreater{}\ 7}: (set \texttt{LHS}
    contains element \textbf{greater than}
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}7})
    AND (set \texttt{LHS} contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}})
  \item
    jsonpath \texttt{\$.a\ !=\ 7}: (set \texttt{LHS} contains element
    \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}})
    AND NOT(set \texttt{LHS} contains element
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}7})
  \item
    jsonpath \texttt{(\$.a\ ==\ 7)\ \&\&\ !\ (\$.b\ ==\ 8)}: (set
    \texttt{LHS} contains element
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}7})
    AND NOT(set \texttt{LHS} contains element
    \texttt{\textless{}key\textgreater{}b.\textless{}num\textgreater{}8})
  \item
    jsonpath \texttt{\$.a\ like\_regex\ "\^{}foo.*bar"}: set
    \texttt{LHS} contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}str\textgreater{}}
    + recheck
  \item
    jsonpath \texttt{\$.a\ starts\ with\ "bar"}: set \texttt{LHS}
    contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}str\textgreater{}bar}
  \item
    jsonpath \texttt{\$.a.ceiling()\ ==\ 5}: set \texttt{LHS} contains
    element
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}}
    + recheck
  \item
    jsonpath \texttt{\$.a.type()\ ==\ "number"}: set \texttt{LHS}
    contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}}
  \item
    jsonpath \texttt{\$.a\ +\ (\$.b\ \%\ \$.c)\ ==\ 7}: (set
    \texttt{LHS} contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}a.\textless{}num\textgreater{}})
    AND (set \texttt{LHS} contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}b.\textless{}num\textgreater{}})
    AND (set \texttt{LHS} contains element \textbf{with prefix}
    \texttt{\textless{}key\textgreater{}c.\textless{}num\textgreater{}})
    + recheck
  \end{oparts}
\end{oparts}
